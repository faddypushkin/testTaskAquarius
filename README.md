# Тестовое задание на вакансию стажёра програмиста микроконтроллеров (embedded-разработчика) в компанию «Аквариус»

## Задача
------
Сторона A хочет передать стороне Б код от банковской ячейки, состоящий из 6 цифр (например, 748253), используя для этого голубиную почту.
Никто не знает о договоренности А и Б пользоваться голубиной почтой для пересылки кода от ячейки, однако:
    - данный способ не позволяет передавать сообщения длиннее 5 цифр;
    - часть голубей может не долететь до получателя (их могут съесть по пути ястребы), но при благоприятных условиях голуби преодолевают расстояние между А и Б за время не более 1 часа;
    - покупать и обучать голубей очень дорого, поэтому желательно ограничить их число при пересылке кода.

Требуется реализовать ПО (клиент и сервер), демонстрирующее решение данной задачи с учетом следующих требований:
1) Язык реализации: C
         Компилятор: GCC
         Микроконтроллер: [STM32L433VC](https://www.st.com/en/microcontrollers-microprocessors/stm32l433vc.html)
2) В качестве системы сборки проектов использовать [GNU Make](https://www.gnu.org/software/make/) или [CMake](https://cmake.org/).
3) В качестве системы документирования кода проектов использовать [Doxygen](https://www.doxygen.nl/).
4) Обмен данными между клиентом и сервером реализовать через UART.
5) Допускается использование сторонних библиотек (находящихся в открытом доступе), не решающих за Вас задачу полностью, при указании ссылки на данную библиотеку и её документацию.
6) К решению задачи приложить описание реализованного алгоритма. Достаточно в виде текстового файла с разметкой [Markdown](https://ru.wikipedia.org/wiki/Markdown).
7) Исходные тексты разместить на сервисе [GitFlic](https://gitflic.ru/) или [GitHub](https://github.com/) в виде публичных репозиториев.

## Решение
-------------
### Использовалось:
 - язык компиляции: C;
 - компилятор [GCC](https://web.archive.org/web/20220423132709/https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads);
 - микроконтроллер [STM32L433VCI3](https://www.st.com/en/microcontrollers-microprocessors/stm32l433vc.html);
 - программа для предварительной настройки МК и инициализации начального кода [STM32CubeMX](https://www.st.com/en/development-tools/stm32cubemx.html);
 - библиотека HAL для STM32L4 ([ссылка](https://disk.yandex.ru/d/r74X5RML0KI0EA/STM32Cube_FW_Library_C_F_G_H_L_MP/STM32L4), [документация](https://www.st.com/resource/en/user_manual/um1884-description-of-stm32l4l4-hal-and-lowlayer-drivers-stmicroelectronics.pdf));
 - система сборки проектов [GNU Make](https://www.gnu.org/software/make/);
 - ПО для программирования и отладки [OpenOCD](https://gnutoolchains.com/arm-eabi/openocd/) (команда make flash);
 - Система документирования [Doxygen](https://www.doxygen.nl/).

### Основные настройки в STM32CubeMX:
 - частота системы тактирования МК - 80МГц;
 - для внутреннего прерывания выбран TIM2 с Prescaler - 40 000 (-> счёт раз в 0,5 мс) и Counter Period - 7 200 000 (-> срабатывает раз в час);
 - выбран USART1 c Boud Rate - 9600 Bits/s, Word Length - 8 Bits, Stop Bits - 1;
 - остальные параметры остались в конфигурации, которую автоматически создаёт CubeMX.

### Описание алгоритма:
Делим код из шести цифр пополам (например, 748253 -> 748 / 253), так как голуби не могут передать его за один раз.

В пункте А человек отправляет в сторону пункта Б двух голубей, выполняя следующие условия:
- сообщения составлены определённым образом, например, "1-***" , то есть первый симаол - маркировка части кода ("1" для первой, "2" для второй), три цифры кода у каждого (последние три числа в сообщении) -> два сообщения с разными частями кода в каждом;
- минимальный промежуток времени между сообщениями (чтобы в пункте Б сообшения обработали за один раз);
- при получении сообщения "There is no the first part of the code" из пункта Б, отправляется повторно только первая часть (при сообщении "There is no the second part of the code", отправляется повторно только вторая часть);
- при отсутсвии любого ответа (голуби не долетели в какой-то из пунктов из-за ястребов) в течении двух часов (т.к. голуби преодолевают расстояние между А и Б за время не более 1 часа), два сообщения с разними частями кода отправляются повторно;
- сообщение "There are all parts of the code" означает, что пункт Б получил все части кода. 

В пункте Б разместить двух людей:
- первый человек (в бесконечном цикле функции main) будет всё время ждать голубя с письмом (функция HAL_UART_Receive_IT(&huart1, message, 5)), а когда письмо будет получено, обрабатывать его (функция selectMessage()), т.е. записывать какую часть (поднимать флаг firstPartOfMessage или secondPartOfMessage) и что получил (записывать информацию из сообщения в массивы firstPartOfCode или secondPartOfCode);
- второй человек будет приходить раз в час (внутреннее прерывание с вызывом Callback функции) и анализировать (функция analysisMessage), какую информацию получил первый (в бесконечном цикле функции main):
  - если не была получена ни одна часть кода, то он ничего не делает;
  - если была получена только одна часть кода (флаг firstPartOfMessage или secondPartOfMessage поднят), то он отправляет сообщение "There is no the first part of the code" или "There is no the second part of the code", в зависимости от того какая часть данных не получена, чтобы в пункте А повторили отправку;
  - если было получено две части сообщения, то он он отправляет в пункт А сообщение "There are all parts of the code", это означает, что код полностью получен (также опускаются все флаги -> МК может получить ещё один код).
